<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 9: API Testing and JSON Responses - Flask Testing Mastery</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/prism.css">
</head>
<body>
    <div class="container">
        <div class="nav-links">
            <a href="chapter08.html">← Previous Chapter</a>
            <a href="index.html">Index</a>
            <a href="chapter10.html">Next Chapter →</a>
        </div>

        <h1>Chapter 9: API Testing and JSON Responses</h1>
        <p class="chapter-subtitle">Building and Testing RESTful APIs with Confidence</p>

        <div class="github-links">
            <span class="github-label">Chapter Code:</span>
            <a href="https://github.com/goodkent/flask-testing/tree/ch09-end" class="github-link">Browse</a>
            <a href="https://github.com/goodkent/flask-testing/archive/refs/tags/ch09-end.zip" class="github-link">Zip</a>
            <a href="https://github.com/goodkent/flask-testing/compare/ch08-end...ch09-end" class="github-link">Diff</a>
        </div>

        <div class="intro-section">
            <p>Welcome back! In the previous chapter, you learned how to organize your Flask application into blueprints and use the application factory pattern. You refactored FlaskBlog Pro into a modular structure with separate blueprints for authentication, posts, comments, and admin functionality. This gave you a professional, maintainable codebase.</p>

            <p>But there's something missing: a proper REST API. Modern web applications don't just serve HTML pages—they also expose JSON APIs that can be consumed by mobile apps, single-page applications (SPAs), or other services. You might have noticed that all your tests so far have focused on HTML responses. What about testing API endpoints that return JSON?</p>

            <p>Testing JSON APIs requires a different approach. Instead of checking for HTML elements or redirects, you need to validate JSON structure, test status codes, verify response schemas, and ensure pagination works correctly. You need to test that your API handles errors gracefully and returns meaningful error messages. You might even need to test API versioning or rate limiting!</p>

            <p>In this chapter, you're going to learn how to build and test a comprehensive REST API for FlaskBlog Pro. You'll create API endpoints for posts, implement schema validation with Marshmallow, add pagination and filtering, and test everything thoroughly. You'll discover how to use jsonschema for response validation, how to test edge cases in JSON APIs, and how to organize your API tests effectively. By the end, you'll have a production-ready REST API with extensive test coverage!</p>
        </div>

        <h2>Learning Objectives</h2>
        <ul>
            <li>Understand the differences between testing HTML and JSON responses</li>
            <li>Create a REST API blueprint with proper HTTP methods</li>
            <li>Validate JSON responses using Marshmallow schemas</li>
            <li>Test pagination with limit and offset parameters</li>
            <li>Implement and test filtering and search functionality</li>
            <li>Test error responses and status codes</li>
            <li>Handle API versioning in tests</li>
            <li>Test rate limiting and API throttling</li>
        </ul>

        <h2>Why APIs Need Different Testing</h2>

        <p>Before we start building the API, let me explain why JSON APIs require a different testing approach than HTML routes.</p>

        <p>When you test HTML routes, you typically check:</p>
        <ul>
            <li>That certain text appears in the response</li>
            <li>That forms are rendered correctly</li>
            <li>That redirects happen to the right place</li>
            <li>That the correct template was used</li>
        </ul>

        <p>But with JSON APIs, you need to verify:</p>
        <ul>
            <li>The exact structure of the JSON response</li>
            <li>That all required fields are present</li>
            <li>That field types are correct (strings, numbers, booleans)</li>
            <li>That arrays have the expected number of items</li>
            <li>That nested objects are properly formatted</li>
            <li>That HTTP status codes are appropriate</li>
            <li>That error responses follow a consistent format</li>
        </ul>

        <p>Think about a simple blog post API endpoint. The HTML version might return a full page with navigation, sidebars, and formatting. The JSON version needs to return just the data in a predictable structure:</p>

        <pre><code class="language-python"># HTML response (from earlier chapters)
&lt;html&gt;
  &lt;h1&gt;My First Post&lt;/h1&gt;
  &lt;p&gt;This is the content...&lt;/p&gt;
  &lt;p&gt;Author: john_doe&lt;/p&gt;
&lt;/html&gt;

# JSON response (what we're building now)
{
    "id": 1,
    "title": "My First Post",
    "content": "This is the content...",
    "author": {
        "id": 42,
        "username": "john_doe"
    },
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
}</code></pre>

        <p>With JSON, you can't just check if "My First Post" appears somewhere in the response. You need to verify that the title field exists, that it's a string, that it has the expected value, and that it's at the correct nesting level. This is where schema validation comes in!</p>

        <div class="note">
            <strong>A Note on Content Negotiation</strong><br>
            Some APIs use the same URLs for both HTML and JSON, deciding what to return based on the <code>Accept</code> header. For FlaskBlog Pro, we'll keep things simpler by using a separate <code>/api</code> blueprint. This makes testing easier and the API more explicit.
        </div>

        <h2>Setting Up Marshmallow for Schema Validation</h2>

        <p>To test JSON responses effectively, we need a way to validate their structure. Marshmallow is a Python library that lets you define schemas for your data and validate JSON against those schemas. It's perfect for API testing!</p>

        <p>First, let's install Marshmallow:</p>

        <pre><code class="language-bash">(venv) $ pip install marshmallow</code></pre>

        <p>Now, let's create schemas for our blog posts. We'll define what fields a post should have and what types they should be:</p>

        <pre><code class="language-python"># app/schemas.py
from marshmallow import Schema, fields, validate

class UserSchema(Schema):
    """Schema for user data in API responses."""
    id = fields.Int(required=True)
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    created_at = fields.DateTime(required=True)
    
    class Meta:
        # Only include these fields in the output
        fields = ('id', 'username', 'email', 'created_at')

class PostSchema(Schema):
    """Schema for blog post data in API responses."""
    id = fields.Int(required=True)
    title = fields.Str(required=True, validate=validate.Length(min=1, max=200))
    content = fields.Str(required=True)
    author = fields.Nested(UserSchema, required=True)
    created_at = fields.DateTime(required=True)
    updated_at = fields.DateTime(required=True)
    
    class Meta:
        fields = ('id', 'title', 'content', 'author', 'created_at', 'updated_at')</code></pre>

        <p>These schemas do two important things:</p>
        <ol>
            <li><strong>Serialization:</strong> They convert your SQLAlchemy models into JSON dictionaries</li>
            <li><strong>Validation:</strong> They verify that data has the correct structure and types</li>
        </ol>

        <p>Notice how <code>PostSchema</code> includes a nested <code>UserSchema</code> for the author field. This is how you handle relationships in your API responses. When a post is serialized, the author will be included as a nested object, not just an ID.</p>

        <div class="note">
            <strong>Why Not Use <code>.to_dict()</code>?</strong><br>
            You could add a <code>to_dict()</code> method to your models, but Marshmallow gives you much more:
            <ul>
                <li>Automatic type validation</li>
                <li>Field-level validation rules</li>
                <li>Easy filtering of sensitive fields (like passwords)</li>
                <li>Consistent error messages</li>
                <li>Better separation of concerns (your models don't need to know about JSON)</li>
            </ul>
        </div>

        <h2>Creating the API Blueprint</h2>

        <p>Now let's create a new blueprint for our API. This blueprint will handle all the JSON endpoints:</p>

        <pre><code class="language-python"># app/api/__init__.py
from flask import Blueprint

api_bp = Blueprint('api', __name__, url_prefix='/api/v1')

from app.api import posts, users  # Import routes after blueprint creation</code></pre>

        <p>Notice the <code>url_prefix='/api/v1'</code>. This means all routes in this blueprint will start with <code>/api/v1</code>. The "v1" indicates this is version 1 of the API—important for future compatibility! If you later make breaking changes, you could create a v2 API while keeping v1 working for existing clients.</p>

        <p>Now let's add the API endpoints for posts:</p>

        <pre><code class="language-python"># app/api/posts.py
from flask import jsonify, request
from app.api import api_bp
from app.models import Post
from app.schemas import PostSchema
from app import db

post_schema = PostSchema()
posts_schema = PostSchema(many=True)

@api_bp.route('/posts', methods=['GET'])
def get_posts():
    """Get all posts with optional pagination."""
    # Get pagination parameters from query string
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    
    # Limit per_page to prevent abuse
    per_page = min(per_page, 100)
    
    # Query posts with pagination
    posts = Post.query.order_by(Post.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    # Serialize the posts
    result = posts_schema.dump(posts.items)
    
    # Return with pagination metadata
    return jsonify({
        'posts': result,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total_pages': posts.pages,
            'total_items': posts.total
        }
    })

@api_bp.route('/posts/&lt;int:id&gt;', methods=['GET'])
def get_post(id):
    """Get a single post by ID."""
    post = Post.query.get_or_404(id)
    result = post_schema.dump(post)
    return jsonify(result)</code></pre>

        <p>These endpoints demonstrate key API patterns:</p>
        <ul>
            <li><strong>Pagination:</strong> The <code>get_posts</code> endpoint accepts <code>page</code> and <code>per_page</code> parameters</li>
            <li><strong>Limiting abuse:</strong> We cap <code>per_page</code> at 100 to prevent users from requesting thousands of posts at once</li>
            <li><strong>Metadata:</strong> We include pagination information in the response so clients know how many pages exist</li>
            <li><strong>Error handling:</strong> Using <code>get_or_404()</code> automatically returns a 404 error for missing posts</li>
        </ul>

        <p>Now let's register this blueprint in our application factory:</p>

        <pre><code class="language-python"># app/__init__.py (add to create_app function)
def create_app(config_name='default'):
    app = Flask(__name__)
    # ... existing code ...
    
    # Register blueprints
    from app.api import api_bp
    app.register_blueprint(api_bp)
    
    # ... rest of existing code ...
    
    return app</code></pre>

        <h2>Writing Your First API Test</h2>

        <p>Now comes the exciting part: testing your API! Let's create a new test file specifically for API tests:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py
import pytest
import json
from app.models import Post, User
from app import db

def test_get_posts_empty(client):
    """Test getting posts when database is empty."""
    response = client.get('/api/v1/posts')
    
    assert response.status_code == 200
    data = response.get_json()
    
    assert 'posts' in data
    assert 'pagination' in data
    assert len(data['posts']) == 0
    assert data['pagination']['total_items'] == 0

def test_get_posts_returns_json(client, sample_post):
    """Test that get_posts returns valid JSON."""
    response = client.get('/api/v1/posts')
    
    # Check content type
    assert response.content_type == 'application/json'
    
    # Check we can parse the JSON
    data = response.get_json()
    assert data is not None
    
def test_get_posts_structure(client, sample_post):
    """Test that posts have the correct structure."""
    response = client.get('/api/v1/posts')
    data = response.get_json()
    
    assert 'posts' in data
    assert 'pagination' in data
    
    # Check pagination structure
    pagination = data['pagination']
    assert 'page' in pagination
    assert 'per_page' in pagination
    assert 'total_pages' in pagination
    assert 'total_items' in pagination
    
    # Check post structure
    posts = data['posts']
    assert len(posts) > 0
    
    post = posts[0]
    assert 'id' in post
    assert 'title' in post
    assert 'content' in post
    assert 'author' in post
    assert 'created_at' in post
    assert 'updated_at' in post
    
    # Check author structure (nested object)
    author = post['author']
    assert 'id' in author
    assert 'username' in author
    assert 'email' in author</code></pre>

        <p>Let's break down what makes these tests different from HTML route tests:</p>

        <ol>
            <li><strong>Content type checking:</strong> We verify the response is <code>application/json</code>, not HTML</li>
            <li><strong>JSON parsing:</strong> We use <code>response.get_json()</code> to parse the response as JSON</li>
            <li><strong>Structure validation:</strong> We check that specific keys exist in the response</li>
            <li><strong>Nested object testing:</strong> We verify nested structures like the author object</li>
        </ol>

        <p>You'll need a <code>sample_post</code> fixture to make these tests work. Let's add that to your conftest.py:</p>

        <pre><code class="language-python"># tests/conftest.py (add to existing file)
import pytest
from app.models import Post, User
from app import db
from datetime import datetime

@pytest.fixture
def sample_user(app):
    """Create a sample user for testing."""
    with app.app_context():
        user = User(username='testuser', email='test@example.com')
        user.set_password('password123')
        db.session.add(user)
        db.session.commit()
        
        # Refresh to get the ID
        db.session.refresh(user)
        user_id = user.id
        
    return {'id': user_id, 'username': 'testuser', 'password': 'password123'}

@pytest.fixture
def sample_post(app, sample_user):
    """Create a sample post for testing."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        post = Post(
            title='Test Post',
            content='This is test content for the post.',
            author=user,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        db.session.add(post)
        db.session.commit()
        
        db.session.refresh(post)
        post_id = post.id
        
    return {'id': post_id, 'title': 'Test Post'}</code></pre>

        <div class="note">
            <strong>Fixture Dependencies</strong><br>
            Notice how <code>sample_post</code> depends on <code>sample_user</code>. Pytest automatically calls <code>sample_user</code> first, then passes the result to <code>sample_post</code>. This is a powerful pattern for building complex test data!
        </div>

        <p>Now run your tests:</p>

        <pre><code class="language-bash">(venv) $ pytest tests/test_api/test_posts.py -v

tests/test_api/test_posts.py::test_get_posts_empty PASSED
tests/test_api/test_posts.py::test_get_posts_returns_json PASSED
tests/test_api/test_posts.py::test_get_posts_structure PASSED

==================== 3 passed in 0.24s ====================</code></pre>

        <p>Excellent! Your API tests are passing. But we can do better—let's add proper schema validation.</p>

        <h2>Using Marshmallow for Test Validation</h2>

        <p>Right now, you're manually checking each field in the JSON response. This works, but it's tedious and error-prone. What if you forget to check a field? What if the field type is wrong? Marshmallow can validate the entire response for you!</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (add to existing file)
from app.schemas import PostSchema, UserSchema
from marshmallow import ValidationError

def test_post_matches_schema(client, sample_post):
    """Test that post response matches the defined schema."""
    response = client.get(f'/api/v1/posts/{sample_post["id"]}')
    data = response.get_json()
    
    # Validate against schema
    schema = PostSchema()
    try:
        result = schema.load(data)
        # If we get here, the data is valid!
        assert result['title'] == sample_post['title']
    except ValidationError as e:
        pytest.fail(f"Schema validation failed: {e.messages}")

def test_get_posts_all_posts_match_schema(client, sample_post):
    """Test that all posts in the list match the schema."""
    response = client.get('/api/v1/posts')
    data = response.get_json()
    
    schema = PostSchema(many=True)
    try:
        # Validate all posts at once
        posts = schema.load(data['posts'])
        assert len(posts) > 0
    except ValidationError as e:
        pytest.fail(f"Schema validation failed: {e.messages}")</code></pre>

        <p>This is much better! Instead of manually checking each field, you use <code>schema.load()</code> to validate the entire response. If the data doesn't match the schema, you get a clear error message telling you exactly what's wrong.</p>

        <p>Let me show you what happens when a field is missing. Let's temporarily break our API by commenting out the <code>title</code> field in the schema:</p>

        <pre><code class="language-python"># app/schemas.py (temporarily broken for demonstration)
class PostSchema(Schema):
    id = fields.Int(required=True)
    # title = fields.Str(required=True)  # Commented out
    content = fields.Str(required=True)
    # ... rest of fields ...</code></pre>

        <p>Now if you run the tests, you'll see:</p>

        <pre><code class="language-bash">(venv) $ pytest tests/test_api/test_posts.py::test_post_matches_schema -v

FAILED tests/test_api/test_posts.py::test_post_matches_schema
Schema validation failed: {'title': ['Unknown field.']}</code></pre>

        <p>Perfect! Marshmallow immediately told you that there's an unknown field called "title" in your response. This is incredibly useful for catching API changes that might break clients.</p>

        <div class="note">
            <strong>Remember to uncomment the title field!</strong> This was just a demonstration. Your schema should include all required fields.
        </div>

        <h2>Testing Pagination</h2>

        <p>Pagination is critical for APIs that return lists. You can't return thousands of blog posts in a single response—it would be slow and wasteful. Let's test that pagination works correctly:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (add to existing file)
def test_pagination_defaults(client, app, sample_user):
    """Test default pagination values."""
    # Create 15 posts
    with app.app_context():
        user = User.query.get(sample_user['id'])
        for i in range(15):
            post = Post(
                title=f'Post {i}',
                content=f'Content {i}',
                author=user
            )
            db.session.add(post)
        db.session.commit()
    
    response = client.get('/api/v1/posts')
    data = response.get_json()
    
    # Default is page 1, 10 items per page
    assert data['pagination']['page'] == 1
    assert data['pagination']['per_page'] == 10
    assert len(data['posts']) == 10
    assert data['pagination']['total_items'] == 15
    assert data['pagination']['total_pages'] == 2

def test_pagination_custom_page_size(client, app, sample_user):
    """Test custom page size."""
    # Create 25 posts
    with app.app_context():
        user = User.query.get(sample_user['id'])
        for i in range(25):
            post = Post(title=f'Post {i}', content=f'Content {i}', author=user)
            db.session.add(post)
        db.session.commit()
    
    # Request 5 items per page
    response = client.get('/api/v1/posts?per_page=5')
    data = response.get_json()
    
    assert len(data['posts']) == 5
    assert data['pagination']['per_page'] == 5
    assert data['pagination']['total_pages'] == 5

def test_pagination_second_page(client, app, sample_user):
    """Test getting second page of results."""
    # Create 15 posts
    with app.app_context():
        user = User.query.get(sample_user['id'])
        for i in range(15):
            post = Post(title=f'Post {i}', content=f'Content {i}', author=user)
            db.session.add(post)
        db.session.commit()
    
    # Get page 2
    response = client.get('/api/v1/posts?page=2')
    data = response.get_json()
    
    assert data['pagination']['page'] == 2
    assert len(data['posts']) == 5  # 15 total, 10 on page 1, 5 on page 2

def test_pagination_limit_prevents_abuse(client):
    """Test that per_page is limited to prevent abuse."""
    # Try to request 1000 items (should be capped at 100)
    response = client.get('/api/v1/posts?per_page=1000')
    data = response.get_json()
    
    # Should be limited to 100
    assert data['pagination']['per_page'] == 100</code></pre>

        <p>These tests verify that:</p>
        <ul>
            <li>Default pagination values work correctly</li>
            <li>Custom page sizes are respected</li>
            <li>Second (and later) pages return the correct items</li>
            <li>Abuse protection limits page size to a reasonable maximum</li>
        </ul>

        <p>Run the pagination tests:</p>

        <pre><code class="language-bash">(venv) $ pytest tests/test_api/test_posts.py -k pagination -v

tests/test_api/test_posts.py::test_pagination_defaults PASSED
tests/test_api/test_posts.py::test_pagination_custom_page_size PASSED
tests/test_api/test_posts.py::test_pagination_second_page PASSED
tests/test_api/test_posts.py::test_pagination_limit_prevents_abuse PASSED

==================== 4 passed in 0.31s ====================</code></pre>

        <p>Excellent! Your pagination is working correctly and you have tests to prove it.</p>

        <h2>Testing Filtering and Search</h2>

        <p>Most APIs need filtering capabilities. For FlaskBlog Pro, users should be able to search for posts by title or filter by author. Let's add that functionality:</p>

        <pre><code class="language-python"># app/api/posts.py (update get_posts function)
@api_bp.route('/posts', methods=['GET'])
def get_posts():
    """Get all posts with optional pagination, filtering, and search."""
    # Get pagination parameters
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    per_page = min(per_page, 100)
    
    # Start with base query
    query = Post.query
    
    # Apply search filter if provided
    search = request.args.get('search', '')
    if search:
        search_filter = f'%{search}%'
        query = query.filter(
            db.or_(
                Post.title.ilike(search_filter),
                Post.content.ilike(search_filter)
            )
        )
    
    # Apply author filter if provided
    author_id = request.args.get('author_id', type=int)
    if author_id:
        query = query.filter_by(author_id=author_id)
    
    # Order and paginate
    posts = query.order_by(Post.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    result = posts_schema.dump(posts.items)
    
    return jsonify({
        'posts': result,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total_pages': posts.pages,
            'total_items': posts.total
        }
    })</code></pre>

        <p>Now let's test these filtering features:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (add to existing file)
def test_search_by_title(client, app, sample_user):
    """Test searching posts by title."""
    # Create posts with different titles
    with app.app_context():
        user = User.query.get(sample_user['id'])
        Post(title='Python Tutorial', content='Content 1', author=user).add_to_db()
        Post(title='Flask Guide', content='Content 2', author=user).add_to_db()
        Post(title='Python Advanced', content='Content 3', author=user).add_to_db()
        db.session.commit()
    
    # Search for "Python"
    response = client.get('/api/v1/posts?search=Python')
    data = response.get_json()
    
    assert len(data['posts']) == 2
    titles = [p['title'] for p in data['posts']]
    assert 'Python Tutorial' in titles
    assert 'Python Advanced' in titles
    assert 'Flask Guide' not in titles

def test_search_by_content(client, app, sample_user):
    """Test searching posts by content."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        Post(title='Post 1', content='This talks about Flask', author=user).add_to_db()
        Post(title='Post 2', content='This talks about Django', author=user).add_to_db()
        db.session.commit()
    
    response = client.get('/api/v1/posts?search=Flask')
    data = response.get_json()
    
    assert len(data['posts']) == 1
    assert data['posts'][0]['title'] == 'Post 1'

def test_search_case_insensitive(client, app, sample_user):
    """Test that search is case-insensitive."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        Post(title='Python Tutorial', content='Content', author=user).add_to_db()
        db.session.commit()
    
    # Search with different cases
    for search_term in ['python', 'PYTHON', 'PyThOn']:
        response = client.get(f'/api/v1/posts?search={search_term}')
        data = response.get_json()
        assert len(data['posts']) == 1

def test_filter_by_author(client, app, sample_user):
    """Test filtering posts by author."""
    # Create two users
    with app.app_context():
        user1 = User.query.get(sample_user['id'])
        user2 = User(username='author2', email='author2@example.com')
        user2.set_password('password')
        db.session.add(user2)
        db.session.commit()
        
        # Create posts for each author
        Post(title='User1 Post 1', content='Content', author=user1).add_to_db()
        Post(title='User1 Post 2', content='Content', author=user1).add_to_db()
        Post(title='User2 Post 1', content='Content', author=user2).add_to_db()
        db.session.commit()
        
        user1_id = user1.id
    
    # Filter by user1
    response = client.get(f'/api/v1/posts?author_id={user1_id}')
    data = response.get_json()
    
    assert len(data['posts']) == 2
    assert all(p['author']['id'] == user1_id for p in data['posts'])

def test_combined_filters(client, app, sample_user):
    """Test combining search and author filter."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        Post(title='Python Tutorial', content='Content', author=user).add_to_db()
        Post(title='Flask Tutorial', content='Content', author=user).add_to_db()
        db.session.commit()
        user_id = user.id
    
    # Search for "Python" by specific author
    response = client.get(f'/api/v1/posts?search=Python&author_id={user_id}')
    data = response.get_json()
    
    assert len(data['posts']) == 1
    assert data['posts'][0]['title'] == 'Python Tutorial'</code></pre>

        <div class="note">
            <strong>Helper Method for Tests</strong><br>
            Notice the <code>.add_to_db()</code> method in the tests. This is a helper you can add to your Post model to make tests cleaner:
            <pre><code class="language-python"># app/models.py (add to Post class)
class Post(db.Model):
    # ... existing fields ...
    
    def add_to_db(self):
        """Helper method to add and return self for chaining."""
        db.session.add(self)
        return self</code></pre>
        </div>

        <h2>Testing Error Responses</h2>

        <p>Good APIs don't just handle success cases—they also return meaningful errors when something goes wrong. Let's test error scenarios:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (add to existing file)
def test_get_nonexistent_post_returns_404(client):
    """Test that getting a non-existent post returns 404."""
    response = client.get('/api/v1/posts/9999')
    
    assert response.status_code == 404
    data = response.get_json()
    
    # Check error response structure
    assert 'error' in data or 'message' in data

def test_invalid_pagination_parameters(client):
    """Test handling of invalid pagination parameters."""
    # Negative page number
    response = client.get('/api/v1/posts?page=-1')
    data = response.get_json()
    # Should handle gracefully (Flask-SQLAlchemy returns page 1 for invalid pages)
    assert response.status_code == 200
    assert data['pagination']['page'] >= 1

def test_empty_search_returns_all_posts(client, app, sample_user):
    """Test that empty search string returns all posts."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        Post(title='Post 1', content='Content', author=user).add_to_db()
        Post(title='Post 2', content='Content', author=user).add_to_db()
        db.session.commit()
    
    response = client.get('/api/v1/posts?search=')
    data = response.get_json()
    
    # Empty search should return all posts
    assert len(data['posts']) == 2</code></pre>

        <p>Now let's improve our error responses by adding a custom error handler for 404s:</p>

        <pre><code class="language-python"># app/api/__init__.py (add error handler)
from flask import Blueprint, jsonify

api_bp = Blueprint('api', __name__, url_prefix='/api/v1')

@api_bp.errorhandler(404)
def not_found(error):
    """Handle 404 errors with JSON response."""
    return jsonify({
        'error': 'Not Found',
        'message': 'The requested resource does not exist.'
    }), 404

@api_bp.errorhandler(400)
def bad_request(error):
    """Handle 400 errors with JSON response."""
    return jsonify({
        'error': 'Bad Request',
        'message': str(error.description) if hasattr(error, 'description') else 'Invalid request.'
    }), 400

from app.api import posts, users  # Import routes after blueprint creation</code></pre>

        <p>Now update your error test to verify the improved error format:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (update existing test)
def test_get_nonexistent_post_returns_404(client):
    """Test that getting a non-existent post returns 404."""
    response = client.get('/api/v1/posts/9999')
    
    assert response.status_code == 404
    data = response.get_json()
    
    # Verify error format
    assert data['error'] == 'Not Found'
    assert 'message' in data
    assert 'does not exist' in data['message'].lower()</code></pre>

        <h2>Testing POST, PUT, and DELETE</h2>

        <p>So far, we've only tested GET requests. Let's add endpoints for creating, updating, and deleting posts, and test them thoroughly:</p>

        <pre><code class="language-python"># app/api/posts.py (add new endpoints)
from flask import jsonify, request, abort
from flask_login import login_required, current_user

@api_bp.route('/posts', methods=['POST'])
@login_required
def create_post():
    """Create a new post."""
    data = request.get_json()
    
    # Validate required fields
    if not data or 'title' not in data or 'content' not in data:
        abort(400, description='Title and content are required.')
    
    # Validate title length
    if len(data['title']) > 200:
        abort(400, description='Title must be 200 characters or less.')
    
    # Create the post
    post = Post(
        title=data['title'],
        content=data['content'],
        author=current_user
    )
    db.session.add(post)
    db.session.commit()
    
    # Return the created post
    result = post_schema.dump(post)
    return jsonify(result), 201

@api_bp.route('/posts/&lt;int:id&gt;', methods=['PUT'])
@login_required
def update_post(id):
    """Update an existing post."""
    post = Post.query.get_or_404(id)
    
    # Check authorization
    if post.author_id != current_user.id:
        abort(403, description='You can only edit your own posts.')
    
    data = request.get_json()
    
    # Update fields if provided
    if 'title' in data:
        if len(data['title']) > 200:
            abort(400, description='Title must be 200 characters or less.')
        post.title = data['title']
    
    if 'content' in data:
        post.content = data['content']
    
    post.updated_at = datetime.utcnow()
    db.session.commit()
    
    result = post_schema.dump(post)
    return jsonify(result)

@api_bp.route('/posts/&lt;int:id&gt;', methods=['DELETE'])
@login_required
def delete_post(id):
    """Delete a post."""
    post = Post.query.get_or_404(id)
    
    # Check authorization
    if post.author_id != current_user.id:
        abort(403, description='You can only delete your own posts.')
    
    db.session.delete(post)
    db.session.commit()
    
    return '', 204  # No content</code></pre>

        <p>Now let's write comprehensive tests for these endpoints:</p>

        <pre><code class="language-python"># tests/test_api/test_posts.py (add to existing file)
def test_create_post_success(client, sample_user):
    """Test creating a post via API."""
    # Log in first
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    # Create post
    response = client.post('/api/v1/posts', json={
        'title': 'New API Post',
        'content': 'This post was created via the API!'
    })
    
    assert response.status_code == 201
    data = response.get_json()
    
    assert data['title'] == 'New API Post'
    assert data['content'] == 'This post was created via the API!'
    assert 'id' in data
    assert data['author']['username'] == sample_user['username']

def test_create_post_requires_login(client):
    """Test that creating a post requires authentication."""
    response = client.post('/api/v1/posts', json={
        'title': 'Test Post',
        'content': 'Test Content'
    })
    
    # Should redirect to login (302) or return unauthorized (401)
    assert response.status_code in [302, 401]

def test_create_post_missing_fields(client, sample_user):
    """Test that missing required fields returns 400."""
    # Log in
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    # Missing content
    response = client.post('/api/v1/posts', json={
        'title': 'Only Title'
    })
    assert response.status_code == 400
    
    # Missing title
    response = client.post('/api/v1/posts', json={
        'content': 'Only Content'
    })
    assert response.status_code == 400

def test_create_post_title_too_long(client, sample_user):
    """Test that overly long titles are rejected."""
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    response = client.post('/api/v1/posts', json={
        'title': 'x' * 201,  # 201 characters
        'content': 'Content'
    })
    
    assert response.status_code == 400
    data = response.get_json()
    assert 'title' in data['message'].lower()

def test_update_post_success(client, sample_user, sample_post):
    """Test updating a post via API."""
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    response = client.put(f'/api/v1/posts/{sample_post["id"]}', json={
        'title': 'Updated Title',
        'content': 'Updated content'
    })
    
    assert response.status_code == 200
    data = response.get_json()
    assert data['title'] == 'Updated Title'
    assert data['content'] == 'Updated content'

def test_update_post_partial(client, sample_user, sample_post):
    """Test that partial updates work (only updating one field)."""
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    # Update only title
    response = client.put(f'/api/v1/posts/{sample_post["id"]}', json={
        'title': 'New Title Only'
    })
    
    assert response.status_code == 200
    data = response.get_json()
    assert data['title'] == 'New Title Only'
    # Content should be unchanged
    assert 'content' in data

def test_update_someone_elses_post_forbidden(client, app, sample_user, sample_post):
    """Test that users cannot update other users' posts."""
    # Create second user
    with app.app_context():
        user2 = User(username='otheruser', email='other@example.com')
        user2.set_password('password123')
        db.session.add(user2)
        db.session.commit()
    
    # Log in as second user
    client.post('/auth/login', data={
        'username': 'otheruser',
        'password': 'password123'
    })
    
    # Try to update first user's post
    response = client.put(f'/api/v1/posts/{sample_post["id"]}', json={
        'title': 'Trying to update'
    })
    
    assert response.status_code == 403
    data = response.get_json()
    assert 'own posts' in data['message'].lower()

def test_delete_post_success(client, sample_user, sample_post):
    """Test deleting a post via API."""
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    response = client.delete(f'/api/v1/posts/{sample_post["id"]}')
    
    assert response.status_code == 204
    assert response.data == b''  # No content
    
    # Verify post is gone
    response = client.get(f'/api/v1/posts/{sample_post["id"]}')
    assert response.status_code == 404

def test_delete_someone_elses_post_forbidden(client, app, sample_user, sample_post):
    """Test that users cannot delete other users' posts."""
    # Create and log in as second user
    with app.app_context():
        user2 = User(username='otheruser', email='other@example.com')
        user2.set_password('password123')
        db.session.add(user2)
        db.session.commit()
    
    client.post('/auth/login', data={
        'username': 'otheruser',
        'password': 'password123'
    })
    
    response = client.delete(f'/api/v1/posts/{sample_post["id"]}')
    
    assert response.status_code == 403</code></pre>

        <p>Run all your API tests now:</p>

        <pre><code class="language-bash">(venv) $ pytest tests/test_api/ -v

tests/test_api/test_posts.py::test_get_posts_empty PASSED
tests/test_api/test_posts.py::test_get_posts_returns_json PASSED
tests/test_api/test_posts.py::test_get_posts_structure PASSED
tests/test_api/test_posts.py::test_post_matches_schema PASSED
tests/test_api/test_posts.py::test_pagination_defaults PASSED
tests/test_api/test_posts.py::test_create_post_success PASSED
tests/test_api/test_posts.py::test_update_post_success PASSED
tests/test_api/test_posts.py::test_delete_post_success PASSED
... and many more ...

==================== 18 passed in 1.04s ====================</code></pre>

        <p>Excellent! You now have comprehensive tests for a complete CRUD API.</p>

        <h2>Testing Rate Limiting</h2>

        <p>APIs need protection against abuse. One common technique is rate limiting—restricting how many requests a user can make in a time period. Let's add rate limiting using Flask-Limiter:</p>

        <pre><code class="language-bash">(venv) $ pip install Flask-Limiter</code></pre>

        <p>Now configure rate limiting in your application:</p>

        <pre><code class="language-python"># app/__init__.py (add to create_app function)
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"],
    storage_uri="memory://"
)

# Apply stricter limits to API routes
@limiter.limit("10 per minute")
@api_bp.route('/posts', methods=['POST'])
@login_required
def create_post():
    # ... existing code ...</code></pre>

        <p>Now let's test that rate limiting works:</p>

        <pre><code class="language-python"># tests/test_api/test_rate_limiting.py
import pytest
import time

def test_rate_limit_enforced(client, sample_user):
    """Test that rate limiting is enforced."""
    # Log in
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    # Make requests until we hit the rate limit
    responses = []
    for i in range(12):  # Limit is 10 per minute
        response = client.post('/api/v1/posts', json={
            'title': f'Post {i}',
            'content': f'Content {i}'
        })
        responses.append(response.status_code)
    
    # First 10 should succeed (201), 11th and 12th should be rate limited (429)
    assert responses[:10].count(201) == 10
    assert 429 in responses[10:]  # At least one rate limit response

def test_rate_limit_resets(client, sample_user):
    """Test that rate limit resets after time period."""
    # This test would require either:
    # 1. Mocking time (advanced)
    # 2. Waiting for the limit to reset (slow)
    # 3. Using a test-specific limiter with very short windows
    # For demonstration, we'll show the concept:
    
    pytest.skip("Rate limit reset requires time mocking or long waits")</code></pre>

        <div class="note">
            <strong>Testing Rate Limits Can Be Tricky</strong><br>
            Rate limit testing often requires mocking time or using very short time windows in tests. In production, you might use Redis for rate limiting storage, which can be mocked in tests. The key is to verify that the rate limiter is configured correctly, not to test the rate limiting library itself.
        </div>

        <h2>API Versioning</h2>

        <p>You already implemented basic API versioning when you used <code>/api/v1</code> as the URL prefix. This is important because it lets you make breaking changes in v2 while keeping v1 working for existing clients.</p>

        <p>Let's verify versioning works correctly:</p>

        <pre><code class="language-python"># tests/test_api/test_versioning.py
def test_api_v1_accessible(client, sample_post):
    """Test that v1 API is accessible at correct URL."""
    response = client.get('/api/v1/posts')
    assert response.status_code == 200

def test_api_without_version_not_found(client):
    """Test that /api/posts (without version) doesn't exist."""
    response = client.get('/api/posts')
    assert response.status_code == 404

def test_api_versioning_in_response_headers(client, sample_post):
    """Test that API version is included in response headers."""
    response = client.get(f'/api/v1/posts/{sample_post["id"]}')
    
    # You could add a custom header to identify API version
    # This is optional but helpful for clients
    # assert 'X-API-Version' in response.headers
    # assert response.headers['X-API-Version'] == '1.0'
    
    # For now, just verify the URL structure works
    assert response.status_code == 200</code></pre>

        <p>If you later create a v2 API with breaking changes, you can create a new blueprint:</p>

        <pre><code class="language-python"># app/api_v2/__init__.py (future version)
from flask import Blueprint

api_v2_bp = Blueprint('api_v2', __name__, url_prefix='/api/v2')

# Register in app/__init__.py:
# app.register_blueprint(api_v2_bp)</code></pre>

        <p>This way, clients using <code>/api/v1</code> continue working while new clients can use <code>/api/v2</code> with improved features!</p>

        <h2>Directory Structure</h2>

        <p>Your project should now look like this:</p>

        <pre><code class="language-bash">flask-testing/
├── app/
│   ├── __init__.py
│   ├── models.py
│   ├── schemas.py          # NEW: Marshmallow schemas
│   ├── api/                # NEW: API blueprint
│   │   ├── __init__.py     # Blueprint and error handlers
│   │   ├── posts.py        # Post API endpoints
│   │   └── users.py        # User API endpoints (optional)
│   ├── auth/
│   │   ├── __init__.py
│   │   └── routes.py
│   └── posts/
│       ├── __init__.py
│       └── routes.py
├── tests/
│   ├── conftest.py
│   ├── test_api/           # NEW: API tests
│   │   ├── __init__.py
│   │   ├── test_posts.py   # Post API tests
│   │   ├── test_rate_limiting.py
│   │   └── test_versioning.py
│   ├── test_auth/
│   └── test_posts/
├── config.py
└── requirements.txt</code></pre>

        <h2>Troubleshooting Common API Testing Issues</h2>

        <div class="troubleshooting">
            <h3>Problem: <code>response.get_json()</code> returns None</h3>
            <p><strong>Solution:</strong> Check that your route is returning JSON with the correct content type:</p>
            <pre><code class="language-python"># Wrong - returns tuple, not JSON
return {'data': 'value'}, 200

# Right - use jsonify
return jsonify({'data': 'value'}), 200</code></pre>

            <h3>Problem: Schema validation always fails</h3>
            <p><strong>Solution:</strong> Make sure you're using <code>schema.load()</code> for incoming data and <code>schema.dump()</code> for outgoing data:</p>
            <pre><code class="language-python"># For testing responses (serialization):
result = schema.dump(post)

# For validating incoming data (deserialization):
data = schema.load(request.get_json())</code></pre>

            <h3>Problem: Pagination tests fail with "has no pages attribute"</h3>
            <p><strong>Solution:</strong> Make sure you're using <code>.paginate()</code> which returns a Pagination object, not <code>.all()</code>:</p>
            <pre><code class="language-python"># Wrong
posts = Post.query.all()
# posts.pages doesn't exist!

# Right
posts = Post.query.paginate(page=1, per_page=10)</code></pre>

            <h3>Problem: Tests pass individually but fail when run together</h3>
            <p><strong>Solution:</strong> This often indicates tests are sharing state. Make sure:</p>
            <ul>
                <li>Each test uses its own database (your <code>app</code> fixture should create a fresh database)</li>
                <li>You're not relying on data from previous tests</li>
                <li>Fixtures are properly scoped (usually 'function' scope for database fixtures)</li>
            </ul>

            <h3>Problem: Authentication tests fail - "Forbidden" instead of "Unauthorized"</h3>
            <p><strong>Solution:</strong> Flask-Login returns different status codes based on configuration:</p>
            <pre><code class="language-python"># In tests, check for either:
assert response.status_code in [302, 401, 403]

# Or configure Flask-Login in your test config:
app.config['LOGIN_DISABLED'] = False  # Ensure auth is active in tests</code></pre>

            <h3>Problem: Rate limiting doesn't work in tests</h3>
            <p><strong>Solution:</strong> Flask-Limiter uses the client's IP address by default. In tests, all requests come from the same IP. You might need to:</p>
            <ul>
                <li>Use a different key function (like user ID) for testing</li>
                <li>Configure a separate limiter for tests with stricter limits</li>
                <li>Mock the limiter's storage backend</li>
            </ul>
        </div>

        <h2>Hands-On Exercise: Build a Comments API</h2>

        <div class="exercise">
            <h3>Goal</h3>
            <p>Create a complete REST API for comments with full test coverage. Comments belong to posts and users can create, read, update, and delete comments.</p>

            <h3>Requirements</h3>
            
            <h4>1. Create Comment Schema</h4>
            <p>In <code>app/schemas.py</code>, create a <code>CommentSchema</code> with these fields:</p>
            <ul>
                <li><code>id</code> (int, required)</li>
                <li><code>content</code> (string, required, max 500 characters)</li>
                <li><code>author</code> (nested UserSchema, required)</li>
                <li><code>post_id</code> (int, required)</li>
                <li><code>created_at</code> (datetime, required)</li>
                <li><code>updated_at</code> (datetime, required)</li>
            </ul>

            <h4>2. Create API Endpoints</h4>
            <p>Create <code>app/api/comments.py</code> with these endpoints:</p>
            <ul>
                <li><code>GET /api/v1/posts/&lt;post_id&gt;/comments</code> - List all comments for a post (with pagination)</li>
                <li><code>GET /api/v1/comments/&lt;id&gt;</code> - Get a single comment</li>
                <li><code>POST /api/v1/posts/&lt;post_id&gt;/comments</code> - Create a comment (requires auth)</li>
                <li><code>PUT /api/v1/comments/&lt;id&gt;</code> - Update a comment (requires auth, own comments only)</li>
                <li><code>DELETE /api/v1/comments/&lt;id&gt;</code> - Delete a comment (requires auth, own comments only)</li>
            </ul>

            <h4>3. Add Filtering</h4>
            <p>Support these query parameters for <code>GET /api/v1/posts/&lt;post_id&gt;/comments</code>:</p>
            <ul>
                <li><code>author_id</code> - Filter comments by author</li>
                <li><code>page</code> - Page number for pagination</li>
                <li><code>per_page</code> - Items per page (max 100)</li>
            </ul>

            <h4>4. Write Comprehensive Tests</h4>
            <p>Create <code>tests/test_api/test_comments.py</code> with tests for:</p>
            <ul>
                <li>Getting comments for a post (empty, with data, paginated)</li>
                <li>Getting a single comment by ID</li>
                <li>Creating comments (success, requires auth, validation errors)</li>
                <li>Updating comments (success, authorization checks, partial updates)</li>
                <li>Deleting comments (success, authorization checks)</li>
                <li>Schema validation (all responses match CommentSchema)</li>
                <li>Filtering by author</li>
                <li>Error cases (404 for missing comment, 403 for unauthorized)</li>
            </ul>

            <h3>Success Criteria</h3>
            <p>You should have:</p>
            <ul>
                <li>At least 15 passing tests for the comments API</li>
                <li>All responses validated against the CommentSchema</li>
                <li>Proper HTTP status codes (200, 201, 400, 403, 404)</li>
                <li>Working pagination with metadata</li>
                <li>Authorization checks preventing users from editing others' comments</li>
            </ul>

            <h3>Hints</h3>
            <ul>
                <li>Start with the schema—it defines your API structure</li>
                <li>Write tests first for each endpoint (TDD approach!)</li>
                <li>Use the posts API code as a template</li>
                <li>Don't forget to add <code>comment_schema</code> and <code>comments_schema</code> instances</li>
                <li>Remember to import and register the comments routes in <code>app/api/__init__.py</code></li>
            </ul>

            <h3>Starter Test to Get You Going</h3>
            <pre><code class="language-python"># tests/test_api/test_comments.py
import pytest
from app.models import Comment, Post, User
from app import db

@pytest.fixture
def sample_comment(app, sample_user, sample_post):
    """Create a sample comment for testing."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        post = Post.query.get(sample_post['id'])
        comment = Comment(
            content='This is a test comment',
            author=user,
            post=post
        )
        db.session.add(comment)
        db.session.commit()
        db.session.refresh(comment)
        comment_id = comment.id
    
    return {'id': comment_id, 'content': 'This is a test comment'}

def test_get_post_comments(client, sample_comment, sample_post):
    """Test getting all comments for a post."""
    response = client.get(f'/api/v1/posts/{sample_post["id"]}/comments')
    
    assert response.status_code == 200
    data = response.get_json()
    
    assert 'comments' in data
    assert 'pagination' in data
    assert len(data['comments']) > 0

# Add more tests following the patterns you learned!</code></pre>
        </div>

        <h2>What We've Learned</h2>

        <p>Take a moment to appreciate everything you've accomplished in this chapter:</p>

        <ul>
            <li>✓ You understand why JSON APIs require different testing approaches than HTML routes</li>
            <li>✓ You can use Marshmallow to define schemas and validate API responses</li>
            <li>✓ You know how to create RESTful API endpoints with proper HTTP methods and status codes</li>
            <li>✓ You've implemented comprehensive pagination with metadata</li>
            <li>✓ You can test filtering and search functionality in APIs</li>
            <li>✓ You understand how to structure error responses consistently</li>
            <li>✓ You've tested authorization in API endpoints (users can only modify their own resources)</li>
            <li>✓ You know how to implement and test API versioning</li>
            <li>✓ You've learned about rate limiting and how to test it</li>
            <li>✓ You can validate JSON response structure at multiple levels</li>
            <li>✓ You've built a production-ready REST API with extensive test coverage</li>
        </ul>

        <p>API testing is a crucial skill for modern web development. Almost every application needs to expose JSON endpoints for mobile apps, SPAs, or third-party integrations. What you've learned here—schema validation, pagination testing, authorization checks, and error handling—applies to any REST API you'll build. The patterns you've practiced (validating structure with schemas, testing edge cases, checking status codes) will serve you in every API project!</p>

        <h2>Before You Continue...</h2>

        <p>Before moving on to Chapter 10, make sure you:</p>

        <ol>
            <li>Can create a REST API blueprint with versioned URL prefixes</li>
            <li>Understand how to use Marshmallow schemas for serialization and validation</li>
            <li>Know the difference between testing JSON responses and HTML responses</li>
            <li>Can implement and test pagination with limit/offset or page/per_page parameters</li>
            <li>Understand how to test filtering and search in API endpoints</li>
            <li>Know how to test POST, PUT, and DELETE endpoints with proper authorization</li>
            <li>Can verify JSON response structure using schema validation</li>
            <li>Have completed the comments API exercise with comprehensive tests</li>
            <li>Understand API versioning and why it's important</li>
            <li>Know how to structure error responses consistently</li>
        </ol>

        <p>If something doesn't make complete sense yet, that's okay! API testing has many moving parts—schemas, pagination, authorization, error handling. The key insight is this: treat your API as a contract with your clients. Your tests verify that this contract is upheld. Every endpoint should return predictable JSON structures, proper status codes, and meaningful error messages. Everything else follows from maintaining this contract. You'll see more API patterns and testing strategies throughout the rest of this course!</p>

        <div class="success">
            <strong>Next Up:</strong> In Chapter 10, you're going to learn about end-to-end testing with Selenium. While unit and API tests are great, they don't test your application the way real users experience it—in a browser with JavaScript, CSS, and user interactions. You'll discover how to automate browser testing, use the Page Object Model pattern, and test JavaScript-heavy features. Modern web apps often have complex front-end behavior, and you'll learn how to test it all with confidence!
        </div>

        <div class="nav-links">
            <a href="chapter08.html">← Previous Chapter</a>
            <a href="index.html">Index</a>
            <a href="chapter10.html">Next Chapter →</a>
        </div>

        <footer>
            <p>Flask Testing Mastery - A comprehensive course on testing Flask applications</p>
            <p style="font-size: 0.9em;">Questions or feedback? Let me know!</p>
        </footer>
    </div>

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>
</html>