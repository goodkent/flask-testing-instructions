<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8: Testing Flask Blueprints and Application Factory - Flask Testing Mastery</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/prism.css">
</head>
<body>
    <div class="container">
        <div class="nav-links">
            <a href="chapter07.html">← Previous Chapter</a>
            <a href="index.html">Index</a>
            <a href="chapter09.html">Next Chapter →</a>
        </div>

        <h1>Chapter 8: Testing Flask Blueprints and Application Factory</h1>
        <p class="chapter-subtitle">Building and Testing Modular Flask Applications</p>

        <div class="github-links">
            <span class="github-label">Chapter Code:</span>
            <a href="https://github.com/goodkent/flask-testing/tree/ch08-end" class="github-link">Browse</a>
            <a href="https://github.com/goodkent/flask-testing/archive/refs/tags/ch08-end.zip" class="github-link">Zip</a>
            <a href="https://github.com/goodkent/flask-testing/compare/ch07-end...ch08-end" class="github-link">Diff</a>
        </div>

        <div class="intro-section">
            <p>Welcome back! In the previous chapter, you mastered integration testing and learned how to test different parts of your application working together. You wrote tests that verified complete workflows across multiple routes and database operations. This gave you confidence that your application's components integrate correctly.</p>

            <p>But there's a problem you might have noticed: as your FlaskBlog Pro application grows, everything is becoming more tangled together. All your routes are in one file, your models are mixed with configuration code, and your tests are starting to feel repetitive. You might be wondering: how do professional Flask applications stay organized as they scale?</p>

            <p>The answer is <strong>Blueprints</strong> and the <strong>Application Factory pattern</strong>. Blueprints let you organize your application into logical modules (like a "posts" blueprint, an "auth" blueprint, an "admin" blueprint), each with its own routes, templates, and static files. The application factory pattern lets you create multiple instances of your app with different configurations—one for testing, one for development, one for production. Together, these patterns make your Flask application modular, testable, and maintainable.</p>

            <p>In this chapter, you're going to learn how to refactor FlaskBlog Pro into a well-organized blueprint-based application. More importantly, you'll learn how to test blueprints both independently and as part of the whole application. You'll discover how to share fixtures across blueprint tests, how to test blueprint registration, and how to test applications with different configurations. By the end, you'll have a professional Flask application structure that's a joy to work with and test!</p>
        </div>

        <h2>Learning Objectives</h2>
        <ul>
            <li>Understand what Flask Blueprints are and when to use them</li>
            <li>Learn the application factory pattern and why it's essential for testing</li>
            <li>Refactor a monolithic Flask app into modular blueprints</li>
            <li>Test blueprint registration and routing</li>
            <li>Share fixtures effectively across blueprint tests</li>
            <li>Test applications with multiple configurations</li>
            <li>Organize test files to match blueprint structure</li>
        </ul>

        <h2>What Are Flask Blueprints?</h2>

        <p>Before we dive into refactoring code, let me explain what blueprints are and why you need them.</p>

        <p>A Blueprint is Flask's way of organizing related functionality into separate modules. Think of a blueprint as a collection of routes, templates, static files, and error handlers that all belong together. For example, in FlaskBlog Pro, you might have:</p>

        <ul>
            <li><strong>auth blueprint:</strong> handles user registration, login, logout</li>
            <li><strong>posts blueprint:</strong> manages blog post creation, editing, viewing</li>
            <li><strong>comments blueprint:</strong> handles comment creation and moderation</li>
            <li><strong>admin blueprint:</strong> provides administrative functionality</li>
            <li><strong>api blueprint:</strong> exposes REST API endpoints</li>
        </ul>

        <p>Each blueprint is like a mini-application that can't run on its own—it needs to be registered with a real Flask app. This is brilliant for testing! You can test each blueprint independently, or you can test them all together as they work in production.</p>

        <div class="note">
            <strong>Why Not Just Use Multiple Python Files?</strong><br>
            You might be thinking, "Can't I just split my routes across multiple .py files?" Yes, but blueprints give you much more:
            <ul>
                <li>URL prefixes (all auth routes start with <code>/auth</code>)</li>
                <li>Separate template and static folders for each blueprint</li>
                <li>Blueprint-specific error handlers</li>
                <li>The ability to register the same blueprint multiple times with different URL prefixes</li>
                <li>Easy testing of individual modules</li>
            </ul>
        </div>

        <h2>The Application Factory Pattern</h2>

        <p>Now let me introduce you to the application factory pattern. Instead of creating your Flask app at the module level (like <code>app = Flask(__name__)</code>), you create a function that builds and configures your app. This function is called an "application factory."</p>

        <p>Here's what a basic application factory looks like:</p>

        <pre><code class="language-python"># app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app(config_name='default'):
    """Application factory function."""
    app = Flask(__name__)
    
    # Load configuration
    app.config.from_object(f'config.{config_name}Config')
    
    # Initialize extensions
    db.init_app(app)
    
    # Register blueprints
    from app.auth import auth_bp
    from app.posts import posts_bp
    app.register_blueprint(auth_bp)
    app.register_blueprint(posts_bp)
    
    return app</code></pre>

        <p>This simple pattern gives you incredible power for testing. Instead of having one app instance that you configure once, you can create fresh app instances with different configurations whenever you need them:</p>

        <pre><code class="language-python"># Create app for testing
test_app = create_app('testing')

# Create app for development
dev_app = create_app('development')

# Create app for production
prod_app = create_app('production')</code></pre>

        <div class="note">
            <strong>Why Is This Great for Testing?</strong><br>
            The application factory pattern solves several testing problems:
            <ul>
                <li><strong>Isolation:</strong> Each test can have its own app instance with a clean state</li>
                <li><strong>Configuration:</strong> Tests use a testing config (in-memory database, disabled CSRF, etc.)</li>
                <li><strong>No Globals:</strong> The app isn't a global variable that tests can accidentally modify</li>
                <li><strong>Parallel Testing:</strong> Different tests can run simultaneously with different app configs</li>
            </ul>
        </div>

        <h2>Refactoring to Blueprints: Step by Step</h2>

        <p>Let's refactor FlaskBlog Pro to use blueprints and an application factory. Don't worry—I'll show you exactly how to do this step by step, and then we'll write tests to make sure everything works correctly.</p>

        <h3>Step 1: Create the Application Structure</h3>

        <p>First, let's reorganize our project structure. Here's what we're building towards:</p>

        <pre><code class="language-bash">flask-testing/
├── app/
│   ├── __init__.py          # Application factory
│   ├── models.py            # Database models
│   ├── auth/
│   │   ├── __init__.py      # Auth blueprint
│   │   └── routes.py        # Auth routes
│   ├── posts/
│   │   ├── __init__.py      # Posts blueprint
│   │   └── routes.py        # Post routes
│   └── admin/
│       ├── __init__.py      # Admin blueprint
│       └── routes.py        # Admin routes
├── tests/
│   ├── conftest.py          # Shared fixtures
│   ├── test_auth/
│   │   ├── test_login.py
│   │   └── test_register.py
│   ├── test_posts/
│   │   ├── test_create.py
│   │   └── test_view.py
│   └── test_admin/
│       └── test_dashboard.py
├── config.py                # Configuration classes
└── run.py                   # Application entry point</code></pre>

        <p>Notice how the test structure mirrors the application structure. Each blueprint has its own test directory. This makes it easy to find and maintain tests.</p>

        <h3>Step 2: Create Configuration Classes</h3>

        <p>Let's start with the configuration. Create a <code>config.py</code> file in your project root:</p>

        <pre><code class="language-python"># config.py
import os
from datetime import timedelta

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # Security
    WTF_CSRF_ENABLED = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Lax'
    PERMANENT_SESSION_LIFETIME = timedelta(days=7)
    
    # Application
    POSTS_PER_PAGE = 10
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max upload

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or \
        'sqlite:///dev_flaskblog.db'
    SQLALCHEMY_ECHO = True  # Log all SQL queries

class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    WTF_CSRF_ENABLED = False  # Disable CSRF for testing
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'  # In-memory database
    SERVER_NAME = 'localhost.localdomain'  # Needed for url_for() in tests
    
class ProductionConfig(Config):
    """Production configuration."""
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    
    # Production security enhancements
    SESSION_COOKIE_SECURE = True  # Only send cookie over HTTPS
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Strict'
    
    # Require environment variables in production
    @staticmethod
    def init_app(app):
        Config.init_app(app)
        
        # Ensure critical settings are configured
        if not os.environ.get('DATABASE_URL'):
            raise ValueError("DATABASE_URL environment variable must be set")
        if not os.environ.get('SECRET_KEY'):
            raise ValueError("SECRET_KEY environment variable must be set")

config = {
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}</code></pre>

        <p>Notice how we have a <code>TestingConfig</code> that's optimized for tests: CSRF is disabled (so tests don't need to include CSRF tokens), the database is in-memory (fast!), and we've set a <code>SERVER_NAME</code> so that <code>url_for()</code> works in tests.</p>

        <h3>Step 3: Create the Application Package</h3>

        <p>Now let's create the application package with our factory function. Create <code>app/__init__.py</code>:</p>

        <pre><code class="language-python"># app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from config import config

# Initialize extensions (but don't bind to app yet!)
db = SQLAlchemy()
login_manager = LoginManager()

def create_app(config_name='default'):
    """
    Application factory function.
    
    Args:
        config_name: Name of configuration to use ('testing', 'development', 'production')
        
    Returns:
        Configured Flask application instance
    """
    app = Flask(__name__)
    
    # Load configuration
    app.config.from_object(config[config_name])
    
    # Initialize extensions with app
    db.init_app(app)
    login_manager.init_app(app)
    
    # Configure Flask-Login
    login_manager.login_view = 'auth.login'
    login_manager.login_message = 'Please log in to access this page.'
    
    # Register blueprints
    from app.auth import auth_bp
    from app.posts import posts_bp
    from app.admin import admin_bp
    
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(posts_bp, url_prefix='/posts')
    app.register_blueprint(admin_bp, url_prefix='/admin')
    
    # Create database tables (if they don't exist)
    with app.app_context():
        db.create_all()
    
    return app</code></pre>

        <p>This factory function is the heart of your application. Every time you call <code>create_app()</code>, you get a fresh Flask application configured according to your needs.</p>

        <div class="note">
            <strong>Extension Initialization Pattern</strong><br>
            Notice how we create extensions at the module level (<code>db = SQLAlchemy()</code>), but we initialize them inside the factory function with <code>db.init_app(app)</code>. This is the recommended pattern because:
            <ul>
                <li>Extensions are importable throughout your application</li>
                <li>But they're not bound to an app until you explicitly initialize them</li>
                <li>This allows you to create multiple app instances (crucial for testing)</li>
            </ul>
        </div>

        <h3>Step 4: Create the Models</h3>

        <p>Let's move your models into <code>app/models.py</code>. This keeps all database models in one place:</p>

        <pre><code class="language-python"># app/models.py
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from app import db, login_manager

class User(UserMixin, db.Model):
    """User model for authentication."""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(128))
    is_admin = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    posts = db.relationship('Post', backref='author', lazy='dynamic', 
                           cascade='all, delete-orphan')
    
    def set_password(self, password):
        """Hash and store password."""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """Verify password against stored hash."""
        return check_password_hash(self.password_hash, password)
    
    def __repr__(self):
        return f'&lt;User {self.username}&gt;'

@login_manager.user_loader
def load_user(user_id):
    """Flask-Login user loader callback."""
    return User.query.get(int(user_id))

class Post(db.Model):
    """Blog post model."""
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Foreign keys
    author_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    
    def __repr__(self):
        return f'&lt;Post {self.title}&gt;'</code></pre>

        <h3>Step 5: Create the Auth Blueprint</h3>

        <p>Now we'll create our first blueprint. Start with <code>app/auth/__init__.py</code>:</p>

        <pre><code class="language-python"># app/auth/__init__.py
from flask import Blueprint

auth_bp = Blueprint('auth', __name__)

from app.auth import routes  # Import routes after creating blueprint</code></pre>

        <p>This creates the blueprint and imports the routes. The circular import (blueprint imports routes, routes imports blueprint) works fine because we import routes at the end of the file, after the blueprint is created.</p>

        <p>Now create the routes in <code>app/auth/routes.py</code>:</p>

        <pre><code class="language-python"># app/auth/routes.py
from flask import render_template, redirect, url_for, flash, request, jsonify
from flask_login import login_user, logout_user, current_user
from werkzeug.urls import url_parse
from app import db
from app.auth import auth_bp
from app.models import User

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    """User registration route."""
    if current_user.is_authenticated:
        return redirect(url_for('posts.index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        
        # Validation
        if not username or not email or not password:
            if request.is_json:
                return jsonify({'error': 'Missing required fields'}), 400
            flash('All fields are required.')
            return render_template('auth/register.html'), 400
        
        # Check if user exists
        if User.query.filter_by(username=username).first():
            if request.is_json:
                return jsonify({'error': 'Username already exists'}), 400
            flash('Username already exists.')
            return render_template('auth/register.html'), 400
        
        if User.query.filter_by(email=email).first():
            if request.is_json:
                return jsonify({'error': 'Email already registered'}), 400
            flash('Email already registered.')
            return render_template('auth/register.html'), 400
        
        # Create user
        user = User(username=username, email=email)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        
        if request.is_json:
            return jsonify({
                'message': 'Registration successful',
                'user': {'username': user.username, 'email': user.email}
            }), 201
        
        flash('Registration successful! Please log in.')
        return redirect(url_for('auth.login'))
    
    return render_template('auth/register.html')

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    """User login route."""
    if current_user.is_authenticated:
        return redirect(url_for('posts.index'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        remember = request.form.get('remember', False)
        
        if not username or not password:
            if request.is_json:
                return jsonify({'error': 'Missing credentials'}), 400
            flash('Please provide username and password.')
            return render_template('auth/login.html'), 400
        
        user = User.query.filter_by(username=username).first()
        
        if user is None or not user.check_password(password):
            if request.is_json:
                return jsonify({'error': 'Invalid credentials'}), 401
            flash('Invalid username or password.')
            return render_template('auth/login.html'), 401
        
        login_user(user, remember=remember)
        
        # Redirect to next page or index
        next_page = request.args.get('next')
        if not next_page or url_parse(next_page).netloc != '':
            next_page = url_for('posts.index')
        
        if request.is_json:
            return jsonify({
                'message': 'Login successful',
                'user': {'username': user.username}
            }), 200
        
        return redirect(next_page)
    
    return render_template('auth/login.html')

@auth_bp.route('/logout')
def logout():
    """User logout route."""
    logout_user()
    
    if request.is_json:
        return jsonify({'message': 'Logged out successfully'}), 200
    
    flash('You have been logged out.')
    return redirect(url_for('auth.login'))</code></pre>

        <p>Notice how all these routes belong to the <code>auth_bp</code> blueprint. When you registered the blueprint with <code>url_prefix='/auth'</code>, all these routes automatically get the <code>/auth</code> prefix. So <code>@auth_bp.route('/login')</code> becomes accessible at <code>/auth/login</code>.</p>

        <h3>Step 6: Create the Posts Blueprint</h3>

        <p>Let's create the posts blueprint following the same pattern. Create <code>app/posts/__init__.py</code>:</p>

        <pre><code class="language-python"># app/posts/__init__.py
from flask import Blueprint

posts_bp = Blueprint('posts', __name__)

from app.posts import routes</code></pre>

        <p>And <code>app/posts/routes.py</code>:</p>

        <pre><code class="language-python"># app/posts/routes.py
from flask import render_template, redirect, url_for, flash, request, jsonify
from flask_login import login_required, current_user
from app import db
from app.posts import posts_bp
from app.models import Post

@posts_bp.route('/')
def index():
    """List all blog posts."""
    page = request.args.get('page', 1, type=int)
    per_page = 10
    
    posts = Post.query.order_by(Post.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    if request.is_json:
        return jsonify({
            'posts': [
                {
                    'id': post.id,
                    'title': post.title,
                    'content': post.content,
                    'author': post.author.username,
                    'created_at': post.created_at.isoformat()
                }
                for post in posts.items
            ],
            'page': page,
            'total_pages': posts.pages,
            'total_posts': posts.total
        }), 200
    
    return render_template('posts/index.html', posts=posts)

@posts_bp.route('/create', methods=['GET', 'POST'])
@login_required
def create():
    """Create a new blog post."""
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        
        if not title or not content:
            if request.is_json:
                return jsonify({'error': 'Title and content are required'}), 400
            flash('Title and content are required.')
            return render_template('posts/create.html'), 400
        
        post = Post(title=title, content=content, author=current_user)
        db.session.add(post)
        db.session.commit()
        
        if request.is_json:
            return jsonify({
                'message': 'Post created successfully',
                'post': {
                    'id': post.id,
                    'title': post.title,
                    'author': post.author.username
                }
            }), 201
        
        flash('Post created successfully!')
        return redirect(url_for('posts.view', post_id=post.id))
    
    return render_template('posts/create.html')

@posts_bp.route('/&lt;int:post_id&gt;')
def view(post_id):
    """View a single blog post."""
    post = Post.query.get_or_404(post_id)
    
    if request.is_json:
        return jsonify({
            'id': post.id,
            'title': post.title,
            'content': post.content,
            'author': post.author.username,
            'created_at': post.created_at.isoformat(),
            'updated_at': post.updated_at.isoformat()
        }), 200
    
    return render_template('posts/view.html', post=post)

@posts_bp.route('/&lt;int:post_id&gt;/edit', methods=['GET', 'POST'])
@login_required
def edit(post_id):
    """Edit a blog post."""
    post = Post.query.get_or_404(post_id)
    
    # Only author can edit their post
    if post.author != current_user:
        if request.is_json:
            return jsonify({'error': 'Unauthorized'}), 403
        flash('You can only edit your own posts.')
        return redirect(url_for('posts.view', post_id=post.id)), 403
    
    if request.method == 'POST':
        post.title = request.form.get('title', post.title)
        post.content = request.form.get('content', post.content)
        db.session.commit()
        
        if request.is_json:
            return jsonify({'message': 'Post updated successfully'}), 200
        
        flash('Post updated successfully!')
        return redirect(url_for('posts.view', post_id=post.id))
    
    return render_template('posts/edit.html', post=post)

@posts_bp.route('/&lt;int:post_id&gt;/delete', methods=['POST'])
@login_required
def delete(post_id):
    """Delete a blog post."""
    post = Post.query.get_or_404(post_id)
    
    # Only author or admin can delete
    if post.author != current_user and not current_user.is_admin:
        if request.is_json:
            return jsonify({'error': 'Unauthorized'}), 403
        flash('You can only delete your own posts.')
        return redirect(url_for('posts.view', post_id=post.id)), 403
    
    db.session.delete(post)
    db.session.commit()
    
    if request.is_json:
        return jsonify({'message': 'Post deleted successfully'}), 200
    
    flash('Post deleted successfully!')
    return redirect(url_for('posts.index'))</code></pre>

        <p>Great! Now we have two complete blueprints: <code>auth</code> and <code>posts</code>. Each blueprint handles a specific area of functionality, making the code much more organized and maintainable.</p>

        <h2>Testing the Application Factory</h2>

        <p>Now comes the fun part—testing! The application factory pattern makes testing incredibly straightforward. Let's start by testing the factory function itself.</p>

        <h3>Testing Basic App Creation</h3>

        <p>Create <code>tests/test_app_factory.py</code>:</p>

        <pre><code class="language-python"># tests/test_app_factory.py
import pytest
from app import create_app, db
from config import config

def test_create_app_with_testing_config():
    """Test that create_app works with testing config."""
    app = create_app('testing')
    
    assert app is not None
    assert app.config['TESTING'] is True
    assert app.config['SQLALCHEMY_DATABASE_URI'] == 'sqlite:///:memory:'
    assert app.config['WTF_CSRF_ENABLED'] is False

def test_create_app_with_development_config():
    """Test that create_app works with development config."""
    app = create_app('development')
    
    assert app is not None
    assert app.config['DEBUG'] is True
    assert 'dev_flaskblog.db' in app.config['SQLALCHEMY_DATABASE_URI']

def test_create_app_with_default_config():
    """Test that create_app uses default config when none specified."""
    app = create_app()
    
    assert app is not None
    # Default should be development config
    assert app.config['DEBUG'] is True

def test_app_has_blueprints_registered():
    """Test that all blueprints are registered."""
    app = create_app('testing')
    
    # Get list of registered blueprint names
    blueprint_names = [bp for bp in app.blueprints.keys()]
    
    assert 'auth' in blueprint_names
    assert 'posts' in blueprint_names
    assert 'admin' in blueprint_names

def test_blueprints_have_correct_url_prefix():
    """Test that blueprints are registered with correct URL prefixes."""
    app = create_app('testing')
    
    # Check that blueprints have correct URL prefix
    assert app.blueprints['auth'].url_prefix == '/auth'
    assert app.blueprints['posts'].url_prefix == '/posts'
    assert app.blueprints['admin'].url_prefix == '/admin'

def test_database_tables_created():
    """Test that database tables are created with app."""
    app = create_app('testing')
    
    with app.app_context():
        # Get table names
        inspector = db.inspect(db.engine)
        tables = inspector.get_table_names()
        
        assert 'users' in tables
        assert 'posts' in tables</code></pre>

        <p>These tests verify that your application factory works correctly. Notice how we create fresh app instances for each test—this is the power of the application factory pattern!</p>

        <h2>Sharing Fixtures Across Blueprint Tests</h2>

        <p>When you have multiple blueprints, you don't want to duplicate fixture code in every test file. Instead, you use a <code>conftest.py</code> file to define fixtures that all your tests can share.</p>

        <p>Create or update <code>tests/conftest.py</code>:</p>

        <pre><code class="language-python"># tests/conftest.py
import pytest
from app import create_app, db
from app.models import User, Post

@pytest.fixture
def app():
    """Create application for testing."""
    app = create_app('testing')
    
    with app.app_context():
        db.create_all()
        yield app
        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app):
    """Create test client."""
    return app.test_client()

@pytest.fixture
def runner(app):
    """Create test CLI runner."""
    return app.test_cli_runner()

@pytest.fixture
def auth_headers():
    """Helper fixture for authentication headers."""
    def _make_headers(token=None):
        headers = {'Content-Type': 'application/json'}
        if token:
            headers['Authorization'] = f'Bearer {token}'
        return headers
    return _make_headers

@pytest.fixture
def sample_user(app):
    """Create a sample user for testing."""
    with app.app_context():
        user = User(username='testuser', email='test@example.com')
        user.set_password('password123')
        db.session.add(user)
        db.session.commit()
        
        # Refresh to get ID
        db.session.refresh(user)
        user_id = user.id
        
    # Return dictionary with user data (not the object itself)
    return {
        'id': user_id,
        'username': 'testuser',
        'email': 'test@example.com',
        'password': 'password123'
    }

@pytest.fixture
def admin_user(app):
    """Create an admin user for testing."""
    with app.app_context():
        admin = User(username='admin', email='admin@example.com', is_admin=True)
        admin.set_password('admin123')
        db.session.add(admin)
        db.session.commit()
        
        db.session.refresh(admin)
        admin_id = admin.id
    
    return {
        'id': admin_id,
        'username': 'admin',
        'email': 'admin@example.com',
        'password': 'admin123'
    }

@pytest.fixture
def sample_post(app, sample_user):
    """Create a sample post for testing."""
    with app.app_context():
        user = User.query.get(sample_user['id'])
        post = Post(
            title='Test Post',
            content='This is a test post content.',
            author=user
        )
        db.session.add(post)
        db.session.commit()
        
        db.session.refresh(post)
        post_id = post.id
    
    return {
        'id': post_id,
        'title': 'Test Post',
        'content': 'This is a test post content.',
        'author_id': sample_user['id']
    }

@pytest.fixture
def logged_in_client(client, sample_user):
    """Create a test client with logged-in user."""
    # Log in the user
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    return client</code></pre>

        <p>These fixtures are now available to <em>all</em> your test files! pytest automatically discovers <code>conftest.py</code> and makes its fixtures available throughout your test suite.</p>

        <div class="note">
            <strong>Why Return Dictionaries Instead of Objects?</strong><br>
            Notice that <code>sample_user</code> and <code>sample_post</code> return dictionaries, not the actual database objects. This is important because:
            <ul>
                <li>SQLAlchemy objects are bound to a specific session and app context</li>
                <li>When the fixture's app context ends, those objects become invalid</li>
                <li>Returning a dictionary with the data avoids "DetachedInstanceError"</li>
                <li>Tests can use the ID to fetch fresh objects in their own app context</li>
            </ul>
        </div>

        <h2>Testing the Auth Blueprint</h2>

        <p>Now let's test the auth blueprint. We'll organize our tests in a <code>test_auth</code> directory to mirror our blueprint structure.</p>

        <h3>Testing User Registration</h3>

        <p>Create <code>tests/test_auth/test_register.py</code>:</p>

        <pre><code class="language-python"># tests/test_auth/test_register.py
import pytest
from app.models import User

def test_register_page_loads(client):
    """Test that registration page loads successfully."""
    response = client.get('/auth/register')
    assert response.status_code == 200

def test_successful_registration(client, app):
    """Test successful user registration."""
    response = client.post('/auth/register', data={
        'username': 'newuser',
        'email': 'newuser@example.com',
        'password': 'secure_password123'
    }, follow_redirects=True)
    
    assert response.status_code == 200
    
    # Verify user was created in database
    with app.app_context():
        user = User.query.filter_by(username='newuser').first()
        assert user is not None
        assert user.email == 'newuser@example.com'
        assert user.check_password('secure_password123')

def test_registration_with_existing_username(client, sample_user):
    """Test that registration fails with duplicate username."""
    response = client.post('/auth/register', data={
        'username': sample_user['username'],  # Duplicate!
        'email': 'different@example.com',
        'password': 'password123'
    })
    
    assert response.status_code == 400
    assert b'Username already exists' in response.data

def test_registration_with_existing_email(client, sample_user):
    """Test that registration fails with duplicate email."""
    response = client.post('/auth/register', data={
        'username': 'different_user',
        'email': sample_user['email'],  # Duplicate!
        'password': 'password123'
    })
    
    assert response.status_code == 400
    assert b'Email already registered' in response.data

def test_registration_with_missing_fields(client):
    """Test that registration fails with missing required fields."""
    response = client.post('/auth/register', data={
        'username': 'newuser',
        # Missing email and password
    })
    
    assert response.status_code == 400
    assert b'All fields are required' in response.data

def test_registration_json_api(client, app):
    """Test registration via JSON API."""
    response = client.post('/auth/register', 
        json={
            'username': 'jsonuser',
            'email': 'json@example.com',
            'password': 'secure_pass'
        })
    
    assert response.status_code == 201
    data = response.get_json()
    assert data['message'] == 'Registration successful'
    assert data['user']['username'] == 'jsonuser'
    
    # Verify in database
    with app.app_context():
        user = User.query.filter_by(username='jsonuser').first()
        assert user is not None</code></pre>

        <p>Notice how we're testing both the HTML form flow and the JSON API flow. This is a common pattern in modern Flask applications that serve both web pages and API endpoints.</p>

        <h3>Testing User Login</h3>

        <p>Create <code>tests/test_auth/test_login.py</code>:</p>

        <pre><code class="language-python"># tests/test_auth/test_login.py
import pytest
from flask import session

def test_login_page_loads(client):
    """Test that login page loads successfully."""
    response = client.get('/auth/login')
    assert response.status_code == 200

def test_successful_login(client, sample_user):
    """Test successful login."""
    response = client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    }, follow_redirects=True)
    
    assert response.status_code == 200
    # After login, should redirect to posts index
    assert b'/posts/' in response.request.url.encode()

def test_login_with_invalid_username(client):
    """Test login with nonexistent username."""
    response = client.post('/auth/login', data={
        'username': 'nonexistent',
        'password': 'password123'
    })
    
    assert response.status_code == 401
    assert b'Invalid username or password' in response.data

def test_login_with_wrong_password(client, sample_user):
    """Test login with incorrect password."""
    response = client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': 'wrong_password'
    })
    
    assert response.status_code == 401
    assert b'Invalid username or password' in response.data

def test_login_with_missing_credentials(client):
    """Test login with missing fields."""
    response = client.post('/auth/login', data={
        'username': 'testuser'
        # Missing password
    })
    
    assert response.status_code == 400

def test_login_remember_me(client, sample_user, app):
    """Test login with 'remember me' functionality."""
    with client:
        response = client.post('/auth/login', data={
            'username': sample_user['username'],
            'password': sample_user['password'],
            'remember': True
        })
        
        # Check that session is configured for remember me
        with app.app_context():
            assert session.permanent is True

def test_logout(logged_in_client):
    """Test logout functionality."""
    response = logged_in_client.get('/auth/logout', follow_redirects=True)
    
    assert response.status_code == 200
    assert b'logged out' in response.data.lower()

def test_login_json_api(client, sample_user):
    """Test login via JSON API."""
    response = client.post('/auth/login',
        json={
            'username': sample_user['username'],
            'password': sample_user['password']
        })
    
    assert response.status_code == 200
    data = response.get_json()
    assert data['message'] == 'Login successful'
    assert data['user']['username'] == sample_user['username']

def test_already_logged_in_redirect(logged_in_client):
    """Test that logged-in users are redirected from login page."""
    response = logged_in_client.get('/auth/login', follow_redirects=True)
    
    # Should redirect to posts index
    assert b'/posts/' in response.request.url.encode()</code></pre>

        <p>These tests cover all the important login scenarios: success, failure, "remember me", logout, and preventing already-logged-in users from accessing the login page again.</p>

        <h2>Testing the Posts Blueprint</h2>

        <p>Now let's test the posts blueprint. Create <code>tests/test_posts/test_posts.py</code>:</p>

        <pre><code class="language-python"># tests/test_posts/test_posts.py
import pytest
from app.models import Post

def test_posts_index_loads(client):
    """Test that posts index page loads."""
    response = client.get('/posts/')
    assert response.status_code == 200

def test_posts_index_shows_posts(client, sample_post):
    """Test that posts appear on index page."""
    response = client.get('/posts/')
    
    assert response.status_code == 200
    assert sample_post['title'].encode() in response.data

def test_create_post_requires_login(client):
    """Test that creating post requires authentication."""
    response = client.get('/posts/create')
    
    # Should redirect to login
    assert response.status_code == 302
    assert '/auth/login' in response.location

def test_create_post_authenticated(logged_in_client, app):
    """Test creating a post when logged in."""
    response = logged_in_client.post('/posts/create', data={
        'title': 'New Test Post',
        'content': 'This is brand new content!'
    }, follow_redirects=True)
    
    assert response.status_code == 200
    
    # Verify post was created
    with app.app_context():
        post = Post.query.filter_by(title='New Test Post').first()
        assert post is not None
        assert post.content == 'This is brand new content!'

def test_create_post_missing_fields(logged_in_client):
    """Test that post creation fails with missing fields."""
    response = logged_in_client.post('/posts/create', data={
        'title': 'Only Title'
        # Missing content
    })
    
    assert response.status_code == 400

def test_view_post(client, sample_post):
    """Test viewing a single post."""
    response = client.get(f'/posts/{sample_post["id"]}')
    
    assert response.status_code == 200
    assert sample_post['title'].encode() in response.data
    assert sample_post['content'].encode() in response.data

def test_view_nonexistent_post(client):
    """Test viewing a post that doesn't exist."""
    response = client.get('/posts/99999')
    assert response.status_code == 404

def test_edit_post_requires_login(client, sample_post):
    """Test that editing requires authentication."""
    response = client.get(f'/posts/{sample_post["id"]}/edit')
    
    assert response.status_code == 302
    assert '/auth/login' in response.location

def test_edit_own_post(logged_in_client, sample_post, app, sample_user):
    """Test editing your own post."""
    response = logged_in_client.post(
        f'/posts/{sample_post["id"]}/edit',
        data={
            'title': 'Updated Title',
            'content': 'Updated content'
        },
        follow_redirects=True
    )
    
    assert response.status_code == 200
    
    # Verify updates in database
    with app.app_context():
        post = Post.query.get(sample_post['id'])
        assert post.title == 'Updated Title'
        assert post.content == 'Updated content'

def test_cannot_edit_others_post(client, sample_post, app):
    """Test that users cannot edit posts by other users."""
    # Create a different user and log in
    with app.app_context():
        from app.models import User
        from app import db
        
        other_user = User(username='otheruser', email='other@example.com')
        other_user.set_password('password')
        db.session.add(other_user)
        db.session.commit()
    
    # Log in as the other user
    client.post('/auth/login', data={
        'username': 'otheruser',
        'password': 'password'
    })
    
    # Try to edit sample_post (which belongs to sample_user)
    response = client.post(
        f'/posts/{sample_post["id"]}/edit',
        data={'title': 'Hacked', 'content': 'Hacked'}
    )
    
    assert response.status_code == 403

def test_delete_post(logged_in_client, sample_post, app):
    """Test deleting a post."""
    response = logged_in_client.post(
        f'/posts/{sample_post["id"]}/delete',
        follow_redirects=True
    )
    
    assert response.status_code == 200
    
    # Verify post was deleted
    with app.app_context():
        post = Post.query.get(sample_post['id'])
        assert post is None

def test_admin_can_delete_any_post(client, sample_post, admin_user, app):
    """Test that admins can delete any post."""
    # Log in as admin
    client.post('/auth/login', data={
        'username': admin_user['username'],
        'password': admin_user['password']
    })
    
    response = client.post(
        f'/posts/{sample_post["id"]}/delete',
        follow_redirects=True
    )
    
    assert response.status_code == 200
    
    # Verify deletion
    with app.app_context():
        post = Post.query.get(sample_post['id'])
        assert post is None

def test_posts_json_api(client, sample_post):
    """Test posts listing via JSON API."""
    response = client.get('/posts/', headers={'Accept': 'application/json'})
    
    data = response.get_json()
    assert 'posts' in data
    assert len(data['posts']) > 0
    assert data['posts'][0]['title'] == sample_post['title']</code></pre>

        <p>These tests verify all the main functionality of the posts blueprint: listing, creating, viewing, editing, and deleting posts. We also test important security considerations like preventing users from editing others' posts.</p>

        <h2>Testing Blueprint Isolation</h2>

        <p>One powerful aspect of blueprints is that you can test them in isolation. This is useful when you want to test blueprint functionality without loading the entire application.</p>

        <pre><code class="language-python"># tests/test_blueprint_isolation.py
import pytest
from flask import Flask
from app.auth import auth_bp
from app import db

def test_auth_blueprint_isolation():
    """Test auth blueprint works independently."""
    # Create minimal app with just auth blueprint
    app = Flask(__name__)
    app.config['TESTING'] = True
    app.config['SECRET_KEY'] = 'test-key'
    app.config['WTF_CSRF_ENABLED'] = False
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    
    db.init_app(app)
    app.register_blueprint(auth_bp, url_prefix='/auth')
    
    # Test that auth routes work
    with app.test_client() as client:
        response = client.get('/auth/login')
        assert response.status_code == 200

def test_blueprint_url_prefix_override():
    """Test that blueprint URL prefix can be overridden."""
    from app.posts import posts_bp
    
    app = Flask(__name__)
    app.config['TESTING'] = True
    
    # Register posts blueprint with different prefix
    app.register_blueprint(posts_bp, url_prefix='/blog')
    
    with app.test_client() as client:
        # Routes should now be under /blog instead of /posts
        response = client.get('/blog/')
        assert response.status_code in [200, 302]  # 302 if redirecting

def test_register_same_blueprint_multiple_times():
    """Test registering same blueprint with different prefixes."""
    from app.posts import posts_bp
    
    app = Flask(__name__)
    app.config['TESTING'] = True
    
    # Register posts blueprint multiple times with different names and prefixes
    app.register_blueprint(posts_bp, url_prefix='/posts')
    app.register_blueprint(posts_bp, name='posts_v2', url_prefix='/v2/posts')
    
    assert 'posts' in app.blueprints
    assert 'posts_v2' in app.blueprints</code></pre>

        <p>These tests demonstrate blueprint flexibility—you can test them independently or register them in different configurations. This is incredibly useful for building reusable components!</p>

        <h2>Testing with Multiple Configurations</h2>

        <p>The application factory pattern makes it trivial to test how your application behaves with different configurations. This is essential for catching configuration-related bugs before they reach production.</p>

        <pre><code class="language-python"># tests/test_configurations.py
import pytest
from app import create_app

def test_testing_config():
    """Test application with testing configuration."""
    app = create_app('testing')
    
    assert app.config['TESTING'] is True
    assert app.config['WTF_CSRF_ENABLED'] is False
    assert 'memory' in app.config['SQLALCHEMY_DATABASE_URI']

def test_development_config():
    """Test application with development configuration."""
    app = create_app('development')
    
    assert app.config['DEBUG'] is True
    assert app.config['SQLALCHEMY_ECHO'] is True
    assert 'dev_flaskblog.db' in app.config['SQLALCHEMY_DATABASE_URI']

def test_config_affects_behavior():
    """Test that CSRF is actually disabled in testing config."""
    test_app = create_app('testing')
    dev_app = create_app('development')
    
    # Testing app should have CSRF disabled
    assert test_app.config['WTF_CSRF_ENABLED'] is False
    
    # Development app should have CSRF enabled
    assert dev_app.config['WTF_CSRF_ENABLED'] is True

def test_database_uri_different_per_config():
    """Test that each config uses different database."""
    test_app = create_app('testing')
    dev_app = create_app('development')
    
    test_uri = test_app.config['SQLALCHEMY_DATABASE_URI']
    dev_uri = dev_app.config['SQLALCHEMY_DATABASE_URI']
    
    assert test_uri != dev_uri
    assert 'memory' in test_uri
    assert 'dev_flaskblog.db' in dev_uri

@pytest.mark.parametrize('config_name', ['testing', 'development'])
def test_all_configs_create_valid_app(config_name):
    """Test that all configurations create valid applications."""
    app = create_app(config_name)
    
    assert app is not None
    assert 'auth' in app.blueprints
    assert 'posts' in app.blueprints
    
    # Test that app context works
    with app.app_context():
        from app import db
        assert db is not None</code></pre>

        <p>Using <code>@pytest.mark.parametrize</code>, we can run the same test with different configurations. This ensures all your configurations work correctly!</p>

        <h2>Running Your Tests</h2>

        <p>Let's verify that all our blueprint tests work. From your project root, run:</p>

        <pre><code class="language-bash"># Run all tests
pytest

# Run only auth blueprint tests
pytest tests/test_auth/

# Run only posts blueprint tests  
pytest tests/test_posts/

# Run with verbose output to see each test
pytest -v

# Run tests matching a pattern
pytest -k "login"</code></pre>

        <p>You should see output like this:</p>

        <pre><code class="language-bash">======================== test session starts ========================
collected 35 items

tests/test_app_factory.py::test_create_app_with_testing_config PASSED
tests/test_app_factory.py::test_create_app_with_development_config PASSED
tests/test_app_factory.py::test_app_has_blueprints_registered PASSED
tests/test_auth/test_register.py::test_register_page_loads PASSED
tests/test_auth/test_register.py::test_successful_registration PASSED
tests/test_auth/test_login.py::test_login_page_loads PASSED
tests/test_auth/test_login.py::test_successful_login PASSED
tests/test_posts/test_posts.py::test_posts_index_loads PASSED
tests/test_posts/test_posts.py::test_create_post_authenticated PASSED
...

====================== 35 passed in 2.43s =======================</code></pre>

        <p>If you see all tests passing, congratulations! You've successfully refactored your application to use blueprints and the application factory pattern, and you've written comprehensive tests for everything.</p>

        <div class="troubleshooting">
            <h3>Troubleshooting Common Issues</h3>

            <h4>Problem: ImportError: cannot import name 'auth_bp'</h4>
            <p><strong>Cause:</strong> Circular import issue or blueprint not properly initialized.</p>
            <p><strong>Solution:</strong> Make sure your blueprint is created before importing routes:</p>
            <pre><code class="language-python"># app/auth/__init__.py
from flask import Blueprint

auth_bp = Blueprint('auth', __name__)

from app.auth import routes  # Import AFTER creating blueprint</code></pre>

            <h4>Problem: 'app' has no attribute 'blueprints'</h4>
            <p><strong>Cause:</strong> Trying to access blueprints on something that's not a Flask app.</p>
            <p><strong>Solution:</strong> Make sure you're creating an app with <code>create_app()</code> first:</p>
            <pre><code class="language-python">app = create_app('testing')
assert 'auth' in app.blueprints  # Now this works</code></pre>

            <h4>Problem: RuntimeError: Working outside of application context</h4>
            <p><strong>Cause:</strong> Trying to use database or app-specific features outside app context.</p>
            <p><strong>Solution:</strong> Use the app context manager:</p>
            <pre><code class="language-python">app = create_app('testing')
with app.app_context():
    user = User.query.first()  # Now this works</code></pre>

            <h4>Problem: Routes return 404 when testing blueprints</h4>
            <p><strong>Cause:</strong> Forgetting to include the blueprint's URL prefix.</p>
            <p><strong>Solution:</strong> Remember that blueprints registered with a prefix need it in the URL:</p>
            <pre><code class="language-python"># If blueprint registered with url_prefix='/auth'
response = client.get('/auth/login')  # Correct
response = client.get('/login')       # Wrong - 404!</code></pre>

            <h4>Problem: Tests fail with "DetachedInstanceError"</h4>
            <p><strong>Cause:</strong> Trying to use SQLAlchemy objects outside their session/context.</p>
            <p><strong>Solution:</strong> Access all needed attributes within the app context, or use dictionaries:</p>
            <pre><code class="language-python"># Good - return data as dictionary
@pytest.fixture
def sample_user(app):
    with app.app_context():
        user = User(username='test', email='test@test.com')
        db.session.add(user)
        db.session.commit()
        user_id = user.id
    
    return {'id': user_id, 'username': 'test'}</code></pre>

            <h4>Problem: Flask-Login "Unauthorized" when testing protected routes</h4>
            <p><strong>Cause:</strong> Test client not maintaining session after login.</p>
            <p><strong>Solution:</strong> Use the same client instance and use <code>with client:</code> block:</p>
            <pre><code class="language-python">def test_protected_route(client, sample_user):
    with client:
        # Login
        client.post('/auth/login', data={
            'username': sample_user['username'],
            'password': sample_user['password']
        })
        
        # Session is maintained within this block
        response = client.get('/posts/create')
        assert response.status_code == 200</code></pre>
        </div>

        <h2>Hands-On Exercise: Create the Admin Blueprint</h2>

        <p>Now it's your turn! You're going to create an admin blueprint for FlaskBlog Pro. This blueprint will provide administrative functionality that only admin users can access.</p>

        <div class="exercise">
            <h3>Exercise Requirements</h3>

            <p>Create a new <code>admin</code> blueprint with the following functionality:</p>

            <ol>
                <li>
                    <strong>Dashboard route</strong> (<code>/admin/dashboard</code>)
                    <ul>
                        <li>Shows statistics: total users, total posts, posts today</li>
                        <li>Only accessible to admin users</li>
                        <li>Redirects non-admins to home page</li>
                    </ul>
                </li>
                <li>
                    <strong>Users list route</strong> (<code>/admin/users</code>)
                    <ul>
                        <li>Lists all users in the system</li>
                        <li>Shows username, email, admin status, post count</li>
                        <li>Only accessible to admin users</li>
                    </ul>
                </li>
                <li>
                    <strong>Make admin route</strong> (<code>/admin/users/&lt;int:user_id&gt;/make-admin</code>)
                    <ul>
                        <li>Promotes a user to admin status</li>
                        <li>POST method only</li>
                        <li>Only accessible to existing admins</li>
                    </ul>
                </li>
            </ol>

            <h3>Step-by-Step Guide</h3>

            <p><strong>Step 1: Create the Admin Blueprint</strong></p>
            <p>Create <code>app/admin/__init__.py</code> following the same pattern as the auth and posts blueprints.</p>

            <p><strong>Step 2: Implement the Routes</strong></p>
            <p>Create <code>app/admin/routes.py</code> with the three routes listed above. Use the <code>@login_required</code> decorator and add an additional check for admin status.</p>

            <p><strong>Hint for Admin Check:</strong></p>
            <pre><code class="language-python">from flask_login import current_user
from flask import abort

if not current_user.is_admin:
    abort(403)  # Forbidden</code></pre>

            <p><strong>Step 3: Register the Blueprint</strong></p>
            <p>Update <code>app/__init__.py</code> to import and register your admin blueprint with <code>url_prefix='/admin'</code>.</p>

            <p><strong>Step 4: Write Tests</strong></p>
            <p>Create <code>tests/test_admin/test_admin.py</code> with tests that verify:</p>
            <ul>
                <li>Admin routes require login</li>
                <li>Non-admin users get 403 Forbidden</li>
                <li>Admin users can access dashboard</li>
                <li>Dashboard shows correct statistics</li>
                <li>Users list shows all users</li>
                <li>Make-admin route successfully promotes users</li>
            </ul>

            <h3>Success Criteria</h3>

            <p>You'll know you've completed the exercise successfully when:</p>

            <ol>
                <li>You can access <code>/admin/dashboard</code> with an admin account</li>
                <li>Non-admin users get a 403 error when trying to access admin routes</li>
                <li>The dashboard displays the correct number of users and posts</li>
                <li>All your tests pass: <code>pytest tests/test_admin/</code></li>
                <li>The admin blueprint is registered and appears in <code>app.blueprints</code></li>
            </ol>

            <h3>Bonus Challenges</h3>

            <p>If you finish early, try these enhancements:</p>

            <ul>
                <li>Add a route to delete users: <code>/admin/users/&lt;int:user_id&gt;/delete</code></li>
                <li>Add pagination to the users list</li>
                <li>Create a decorator <code>@admin_required</code> to avoid repeating the admin check</li>
                <li>Add JSON API support to admin routes</li>
                <li>Display posts-per-user ratio on the dashboard</li>
            </ul>

            <h3>Sample Test to Get You Started</h3>

            <pre><code class="language-python"># tests/test_admin/test_admin.py
import pytest

def test_admin_dashboard_requires_login(client):
    """Test that dashboard requires login."""
    response = client.get('/admin/dashboard')
    assert response.status_code == 302  # Redirect to login

def test_non_admin_gets_forbidden(client, sample_user):
    """Test that non-admin users cannot access dashboard."""
    # Log in as regular user
    client.post('/auth/login', data={
        'username': sample_user['username'],
        'password': sample_user['password']
    })
    
    response = client.get('/admin/dashboard')
    assert response.status_code == 403  # Forbidden

def test_admin_can_access_dashboard(client, admin_user):
    """Test that admin users can access dashboard."""
    # Log in as admin
    client.post('/auth/login', data={
        'username': admin_user['username'],
        'password': admin_user['password']
    })
    
    response = client.get('/admin/dashboard')
    assert response.status_code == 200

# Add more tests following these patterns!</code></pre>
        </div>

        <p>Take your time with this exercise—creating and testing a new blueprint from scratch will solidify everything you've learned in this chapter!</p>

        <h2>What We've Learned</h2>

        <p>Take a moment to appreciate everything you've accomplished in this chapter:</p>

        <ul>
            <li>✓ You understand what Flask Blueprints are and why they're essential for large applications</li>
            <li>✓ You can explain the application factory pattern and its benefits for testing</li>
            <li>✓ You've refactored a monolithic Flask application into modular blueprints</li>
            <li>✓ You know how to test blueprint registration and routing</li>
            <li>✓ You can create shared fixtures in conftest.py for use across all tests</li>
            <li>✓ You've learned to test applications with multiple configurations</li>
            <li>✓ You understand how to organize test files to mirror blueprint structure</li>
            <li>✓ You can test blueprints both in isolation and as part of the whole application</li>
            <li>✓ You know how to test protected routes and admin-only functionality</li>
            <li>✓ You've built a professional, scalable Flask application structure</li>
        </ul>

        <p>The blueprint and application factory patterns are cornerstones of professional Flask development. What you've learned here isn't just about testing—it's about building maintainable, modular applications that scale. By organizing your code into blueprints and using the factory pattern, you've made your application easier to test, easier to understand, and easier to extend. These patterns will serve you well in every Flask project you build!</p>

        <h2>Before You Continue...</h2>

        <p>Before moving on to Chapter 9, make sure you:</p>

        <ol>
            <li>Can create an application using the factory pattern with <code>create_app()</code></li>
            <li>Understand how to organize code into blueprints by functionality</li>
            <li>Know how to register blueprints with URL prefixes</li>
            <li>Can create shared fixtures in conftest.py that work across all tests</li>
            <li>Understand the difference between testing blueprints in isolation vs. with the full app</li>
            <li>Have completed the admin blueprint exercise</li>
            <li>Can test applications with different configurations (testing, development, production)</li>
            <li>Know how to avoid common pitfalls like circular imports and context errors</li>
        </ol>

        <p>If something doesn't make complete sense yet, that's okay! Blueprint architecture and the application factory pattern can feel abstract until you've used them in a few projects. The key insight is this: blueprints let you organize your application into logical chunks, and the factory pattern lets you create multiple instances of your app for different purposes (especially testing). Everything else follows from these two principles. You'll see more examples of these patterns throughout the rest of this course!</p>

        <div class="success">
            <strong>Next Up:</strong> In Chapter 9, you're going to dive deep into API testing and JSON responses. You'll learn how to test RESTful APIs thoroughly, validate JSON schemas with marshmallow or pydantic, test pagination and filtering, and even test API versioning and rate limiting. Modern web applications often expose both HTML pages and JSON APIs—you'll learn to test both sides of that coin. Everything you've learned about blueprints will pay off as you create a comprehensive REST API with extensive test coverage!
        </div>

        <div class="nav-links">
            <a href="chapter07.html">← Previous Chapter</a>
            <a href="index.html">Index</a>
            <a href="chapter09.html">Next Chapter →</a>
        </div>

        <footer>
            <p>Flask Testing Mastery - A comprehensive course on testing Flask applications</p>
            <p style="font-size: 0.9em;">Questions or feedback? Let me know!</p>
        </footer>
    </div>

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</body>
</html>